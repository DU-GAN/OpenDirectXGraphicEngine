#pragma once

#include <d3d12.h>
#include <DirectXMath.h>
#include <DirectXPackedVector.h>
#include <D3d12SDKLayers.h>
#include <d3dcompiler.h>
#include "d3dx12.h"
#include <dxgi1_4.h>
#include <wrl.h>

#include <vector>
#include "Exception.h"
#include "AuxiliaryBase.h"

namespace Rendering
{
	/*
		FrameCommand contain a commandAllocator And int value,
			the commandAllocator record this frame command,
			the int value record this frame last command set Fence value.
	*/
	class FrameCommand
	{
	public:
		FrameCommand() {}

		Microsoft::WRL::ComPtr<ID3D12CommandAllocator> cmdListAlloc;	
		UINT fence = 0;
	};
	
	/*
		FrameIndex show next frame index,
		It can only be generated by FrameCommandManager instance.
	*/
	class FrameIndex
	{
	public:
		int GetData()const
		{
			return index;
		}
	private:
		FrameIndex(int _index = 0) :index(_index) {}

		int index;

		friend class FrameCommandManager;
	};

	class FrameCommandManager
	{
	public:
		FrameCommandManager(int _frameNum = 1) :frameNum(_frameNum) 
		{
			if (frameNum < 1)
			{
				Exception::ThrowException(LEVEL_Error, "frame number < 1");
			}
		}

		// create flow: build -> use、reset -> release
		void Build(ID3D12Device* device)
		{
			frameResources.resize(frameNum);
			for (int i = 0; i < frameNum; ++i)
			{
				Exception::CheckResult(
					device->CreateCommandAllocator(
						D3D12_COMMAND_LIST_TYPE_DIRECT,
						IID_PPV_ARGS(frameResources[i].cmdListAlloc.GetAddressOf())));
			}
			isBuild = true;
		}
		
		void Release()
		{
			if (!isBuild)
				Exception::ThrowException(LEVEL_Error, "no build");
			
			FreeVector(frameResources);
			frameCount = 0;

			isBuild = false;
		}

		void Reset(ID3D12Device* device, int _frameNum = 1)
		{
			Release();

			frameNum = _frameNum;
			
			Build(device);
		}

		/*
			Called before change constbuffer and rendering,
			result int value is frame index,
			please use result CommandAllocator to resert commandList,
		*/
		FrameIndex BeginNewFrame(ID3D12CommandQueue* mCommandQueue, ID3D12Fence* fence, 
			ID3D12CommandAllocator*& commandAllocator)
		{
			if (!isBuild)
				Exception::ThrowException(LEVEL_Error, "no build");

			frameCount = (frameCount + 1) % frameNum;
			auto& frameReource = frameResources[frameCount];

			// wait now frame rendering end
			if (frameReource.fence != 0 && fence->GetCompletedValue() < frameReource.fence)   
			{
				HANDLE eventHandle = CreateEventEx(nullptr, nullptr, false, EVENT_ALL_ACCESS);
				Exception::CheckResult(fence->SetEventOnCompletion(frameReource.fence, eventHandle));
				WaitForSingleObject(eventHandle, INFINITE);
				CloseHandle(eventHandle);
			}

			commandAllocator = frameReource.cmdListAlloc.Get();
			return FrameIndex(frameCount);
		}

		// Called after rendering
		void EndFrame(ID3D12CommandQueue* mCommandQueue, ID3D12Fence* fence, UINT64& currentFence)
		{
			if (!isBuild)
				Exception::ThrowException(LEVEL_Error, "no build");

			auto& frameReource = frameResources[frameCount];
			frameReource.fence = ++currentFence;

			Exception::CheckResult(
				mCommandQueue->Signal(fence, currentFence));
		}

	private:
		bool isBuild = false;

		int frameNum;			// record max frame number
		int frameCount = 0;		// record next frame index

		std::vector<FrameCommand> frameResources;
	};
}